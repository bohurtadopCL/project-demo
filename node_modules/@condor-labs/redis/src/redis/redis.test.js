'use strict';
const logger = require('@condor-labs/logger');
const sinon = require('sinon');
const helper = require('./index');
const fs = require('fs');
const redis = require('redis');
const { assert, expect } = require('chai');

const invalidSettings = {
    bar: 'foo'
};
const validSettings = {
    prefix: 'mprefix',
    host: 'mhost',
    port: 1234,
    password: 'mpass'
};
describe('REDIS TESTINGS', () => {

    //helper._setSettings
    describe('When _setSettings function is called', () => {
        let _validateSettingsStub = {};

        beforeEach(() => {
            _validateSettingsStub = sinon.stub(helper, "_validateSettings");
        });

        afterEach(() => {
            _validateSettingsStub.restore();
        });

        it('Should call the helper._validateSettings method once', () => {
            _validateSettingsStub.returns(true);
            helper._setSettings();
            assert.equal(helper._validateSettings.calledOnce, true);
        });

        it('Should throws an error when the settings are invalid and should not set the settings', () => {
            try {
                _validateSettingsStub.returns(false);
                helper._setSettings();
                helper._setSettings(invalidSettings);
            } catch (error) {
                expect(error).to.be.instanceOf(Error);
                expect(error.message).to.be.equal(helper._errorMsgInvalidSetting);
                expect(helper._settings).to.be.equal(undefined);
            }
        });

        it('Should set the settings when they are valid', () => {
            _validateSettingsStub.returns(true);
            helper._setSettings(validSettings);
            expect(helper._settings).to.be.equal(validSettings);
        });
    });

    //helper._validateSettings
    describe('When _validateSettings function is called', () => {
        let loggerErrorStub = {};

        beforeEach(() => {
            loggerErrorStub = sinon.stub(logger, "error").callsFake(() => { });
        });

        afterEach(() => {
            loggerErrorStub.restore();
        });

        it('Should log the right error message when no settings are passed', () => {
            helper._validateSettings();
            expect(loggerErrorStub.calledOnce).to.be.true;
            expect(loggerErrorStub.calledWith(helper._errorMsgUndefinedSetting)).to.be.true;
        });

        it('Should return false when no settings are passed', () => {
            expect(helper._validateSettings()).to.be.equal(false);
        });

        it('Should log the right error message when settings passed have an invalid format', () => {
            helper._validateSettings(invalidSettings);
            expect(loggerErrorStub.calledOnce).to.be.true;
        });

        it('Should returns false when settings passed have an invalid format', () => {
            const result = helper._validateSettings(invalidSettings);
            expect(result).to.be.equal(false);
        });

        it('Should returns false when settings.ssl is true and not sslKeys paths are present', () => {
            const settings = {
                ...validSettings,
                ssl: true
            }
            const result = helper._validateSettings(settings);
            expect(result).to.be.equal(false);
        });

        it('Should not log any error message when settings passed are valid', () => {
            helper._validateSettings(validSettings);
            expect(loggerErrorStub.calledOnce).to.be.equal(false);
        });

        it('Should return true when settings passed are valid', () => {
            const result = helper._validateSettings(validSettings);
            expect(result).to.be.equal(true);
        });
    });

    // //helper.getClient
    describe('When getClient function is called', () => {
        let _validateSettingstub = {};
        let readFileSyncStub = {};
        let createClientStub = {};

        beforeEach(() => {
            _validateSettingstub = sinon.stub(helper, "_validateSettings");
            readFileSyncStub = sinon.stub(fs, "readFileSync").callsFake(() => { });
            createClientStub = sinon.stub(redis, "createClient").callsFake(() => ({
                on: () => { }
            }));
        });

        afterEach(() => {
            _validateSettingstub.restore();
            readFileSyncStub.restore();
            createClientStub.restore();
        });

        it('Should return a valid client when it is already initialized', async () => {
            helper._client = {
                connected: true
            };
            const client = await helper.getClient();
            expect(client).to.be.equal(helper._client);
            helper._client = undefined;
        });

        it('Should calls validateSetting function once when the client has not been initialized', async () => {
            _validateSettingstub.returns(true);
            await helper.getClient();
            expect(_validateSettingstub.calledOnce).to.be.true;
        });

        it('Should throws an error when the settings are invalid', async () => {
            _validateSettingstub.returns(false);
            try {
                await helper.getClient();
            } catch (error) {
                expect(error.message).to.be.equal(helper._errorMsgInvalidSetting);
                expect(error).to.be.instanceOf(Error);
            }
        });

        it('Should set the tls object property to redisOptions object with the right properties when ssl property is configured to true', async () => {
            _validateSettingstub.returns(true);

            validSettings.ssl = true;
            validSettings.sslKeyPath = "sslKeyPath";
            validSettings.sslCertPath = "sslCertPath";
            validSettings.sslCaPath = "sslCaPath";

            await helper.getClient();

            expect(helper._settings).to.have.property('tls');
            expect(helper._settings.tls).to.have.property('key');
            expect(helper._settings.tls).to.have.property('cert');
            expect(helper._settings.tls).to.have.property('ca');

            expect(readFileSyncStub.callCount).to.be.equal(3);

            expect(readFileSyncStub.getCalls()[0].args).be.deep.equal([validSettings.sslKeyPath, { encoding: 'ascii' }]);
            expect(readFileSyncStub.getCalls()[1].args).be.deep.equal([validSettings.sslCertPath, { encoding: 'ascii' }]);
            expect(readFileSyncStub.getCalls()[2].args).be.deep.equal([validSettings.sslCaPath, { encoding: 'ascii' }]);
        });

        it('Should calls redis.createClient once with the right params', async () => {
            _validateSettingstub.returns(true);
            validSettings.ssl = false;

            await helper.getClient();
            expect(createClientStub.calledOnce).to.be.true;
            expect(createClientStub.calledWith(helper._settings)).to.be.true;
        });
    });
});
